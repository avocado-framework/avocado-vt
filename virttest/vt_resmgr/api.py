"""
The resource management APIs, open to the test cases.

A test case can call these APIs to handle the resource directly, e.g.
allocate a volume from a nfs pool, or call the upper-level APIs to
handle a volume indirectly, e.g. create a qcow2 qemu image, the image
manager call these APIs to allocate a volume.

# Register a nfs pool
pool_config = define_resource_pool_config(nfs_pool_name, nfs_pool_params)
pool_id = register_resouce_pool(pool_config)

# Connect the nfs pool from worker nodes
attach_resource_pool(pool_id)

# Create a volume object
volume_config = define_resource_config("image1", "volume", volume_params)
res_id = create_resource_object(volume_config)

# Bind the nfs resource to worker nodes
config = {'bind': {'nodes': ['node1', 'node2']}}
update_resource(res_id, config)

# Allocate the nfs file based volumes
config = {'allocate': {}}
update_resource(res_id, config)

# Release the nfs file based volumes
config = {'release': {}}
update_resource(res_id, config)

# Unbind the nfs resource from node1
config = {'unbind': {'nodes': ['node1']}}
update_resource(res_id, config)

# Unbind the nfs resource
config = {'unbind': {}}
update_resource(res_id, config)

# Destroy the nfs resource
destroy_resource_object(res_id)
"""

import logging

from .vt_resmgr import vt_resmgr


LOG = logging.getLogger("avocado." + __name__)


class PoolNotFound(Exception):
    def __init__(self, pool_id):
        self._pool_id = pool_id

    def __str__(self):
        pool_id = self._pool_id
        return f"Cannot find the pool by id={pool_id}"


class UnknownPoolType(Exception):
    def __init__(self, pool_type):
        self._pool_type = pool_type

    def __str__(self):
        pool_type = self._pool_type
        return f"Unknown pool type {pool_type}"


class PoolNotAvailable(Exception):
    pass


class ResourceNotFound(Exception):
    pass


class ResourceBusy(Exception):
    pass


class ResourceNotAvailable(Exception):
    pass


class UnknownResourceType(Exception):
    pass


def setup_resmgr(resource_pools_params):
    """
    Register all resource pools configured in cluster.json

    :param resource_pools_params: All resource pools' params, defined
                                  in cluster.json, setup_resmgr will
                                  be called in bootstrap
    :type resource_pools_params: dict
    """
    vt_resmgr.setup(resource_pools_params)


def cleanup_resmgr():
    """
    Unregister all resource pools from VT
    """
    vt_resmgr.cleanup()


def startup_resmgr():
    """
    Make all resource pools ready to be used by attaching them to the
    worker nodes
    """
    vt_resmgr.startup()


def teardown_resmgr():
    """
    Unattach all resource pools from the worker nodes, so they cannot
    be accessed
    """
    vt_resmgr.teardown()


def define_resource_pool_config(pool_name, pool_params):
    """
    Define a resource pool's configuration by its cartesian params.

    :param pool_name: The uniq resource pool name
    :type pool_name: string
    :param pool_params: The resource pool's specific params
    :type pool_params: Param
    :return: The resource pool's configuration,
             format: {"meta":{...}, "spec":{...}}
             The specific attributes depend on the specific pool
    :rtype: dict
    """
    return vt_resmgr.define_pool_config(pool_name, pool_params)


def register_resouce_pool(pool_config):
    """
    Register a resource pool, the pool should be ready for use before
    registration, i.e, the users need to setup the resource pool first

    :param pool_config: The pool's configuration, generated by
                        define_resource_pool_config function
    :type pool_config: dict
    :return: The resource pool id
    :rtype: string
    """
    pool_id = vt_resmgr.create_pool_object(pool_config)
    if pool_id is None:
        raise UnknownPoolType(pool_config["meta"]["type"])
    return pool_id


def unregister_resouce_pool(pool_id):
    """
    Unregister a resource pool

    :param pool_id: The id of the pool to unregister
    :type pool_id: string
    """
    vt_resmgr.destroy_pool_object(pool_id)


def attach_resource_pool(pool_id):
    """
    Attach the registered pool to worker nodes, then the pool can be
    accessed by the worker nodes

    :param pool_id: The id of the pool to attach
    :type pool_id: string
    """
    vt_resmgr.attach_pool(pool_id)


def detach_resource_pool(pool_id):
    """
    Detach the pool from the worker nodes, after that, the pool cannot
    be accessed

    :param pool_id: The id of the pool to detach
    :type pool_id: string
    """
    vt_resmgr.detach_pool(pool_id)


def query_resource_pool(pool_id, request=None):
    """
    Query the configuration of a specified resource pool, the general
    format of the configuration:
          {"meta": {"uuid": "xxx"
                    "type": "yyy",}
           "spec": {},
          }

    :param pool_id: The resource pool id
    :type pool_id: string
    :param request: The query content, format:
                      None
                      meta[.<key>]
                      spec[.<key>]
                    Note return the whole configuration if request=None
    :type request: string
    :return: The pool's configuration, e.g request=meta.type, it
             returns: {"type": "filesystem"}
    :rtype: dict
    """
    return vt_resmgr.query_pool(pool_id, request)


def get_all_resource_pools():
    return list(vt_resmgr.pools.keys())


def define_resource_config(resource_name, resource_type, resource_params):
    """
    Define a resource's configuration by its cartesian params

    :param resource_type: The resource type, it's usually implied, e.g.
                          the image's storage resource is a "volume",
                          supported: "volume"
    :type resource_type: string
    :param resource_params: The resource's specific params, usually
                            defined by an upper-level object, e.g.
                            "image1" has a storage resource, so
                              resource_params = image1's params
                            i.e. use image1's params to define its
                            storage resource's configuration
    :type resource_params: Param
    :return: The resource's configuration,
             format: {"meta":{...}, "spec":{...}}
             The specific attributes depend on the specific resource
    :rtype: dict
    """
    pool_id = vt_resmgr.select_pool(resource_type, resource_params)
    if pool_id is None:
        raise PoolNotAvailable()
    pool = vt_resmgr.get_pool_by_id(pool_id)
    return pool.define_resource_config(resource_name,
                                       resource_type,
                                       resource_params,)


def create_resource_object(resource_config):
    """
    Create a resource object without any specific resource allocation.

    :param resource_config: The resource configuration, generated by
                            define_resource_config function
    :type resource_config: dict
    :return: The resource id
    :rtype: string
    """
    pool_config = resource_config["meta"]["pool"]
    pool_id = pool_config["meta"]["uuid"]
    pool = vt_resmgr.get_pool_by_id(pool_id)
    if pool is None:
        raise PoolNotFound(pool_id)
    return pool.create_resource_object(resource_config)


def destroy_resource_object(resource_id):
    """
    Destroy the resource object, the specific resource allocation
    will be released

    :param resource_id: The resource id
    :type resource_id: string
    """
    pool = vt_resmgr.get_pool_by_resource(resource_id)
    pool.destroy_resource_object(resource_id)


def query_resource(resource_id, request=None):
    """
    Query the configuration of a specified resource, the general format
    of the resource configuration:
          {"meta": {"uuid": "xxx"
                    "type": "yyy",
                    "bindings": [],
                    "pool": {"meta": {}, "spec": {}}}
           "spec": {}
    E.g. A storage volume resource
             {'meta': {
                 'uuid': 'res_id1',
                 'type': 'volume',
                 'pool': {"meta": {"uuid": "pool1"}, "spec": {}},
                 'bindings': [{'node': 'node1',
                               'backing': 'ref1'},
                 ]
               },
               'spec': {
                 'size': 65536,
                 'path': '/mnt/sn.qcow2',
               }
             }
    :param resource_id: The resource id
    :type resource_id: string
    :param request: The query content, format:
                      None
                      meta[.<key>]
                      spec[.<key>]
                    Examples:
                      meta
                      spec.size
    :type request: string
    :return: The resource's configuration, e.g request=spec.size, it
             returns: {"size": "123456"}
    :rtype: dict
    """
    pool = vt_resmgr.get_pool_by_resource(resource_id)
    return pool.query_resource(resource_id, request)


def update_resource(resource_id, config):
    """
    Update a resource, the config format:
      {'command': arguments}
    Supported commands:
      'bind': Bind a specified resource to one or more worker nodes in order
              to access the specific resource allocation, note the resource
              is *NOT* allocated with the bind command
      'unbind': Unbind a specified resource from one or more worker nodes,
                the specific resource will be released only when all bindings
                are gone
      'allocate': Allocate the resource
      'release': Release the resource
      'sync': Sync up the resource configuration. Some items of the
              configuration can change and only be fetched on the worker
              nodes, e.g. allocation, use sync to sync-up these items
    The arguments is a dict object which contains all related settings for a
    specific action

    Examples:
      Bind a resource to one or more nodes
        {'bind': {'nodes': ['node1']}}
        {'bind': {'nodes': ['node1', 'node2']}}
      Unbind a resource from one or more nodes
        {'unbind': {'nodes': []}}
        {'unbind': {'nodes': ['node1', 'node2']}}
      Allocate the resource
        {'allocate': {}}
      Release the resource
        {'release': {}}

    :param resource_id: The resource id
    :type resource_id: string
    :param config: The specified action and its arguments
    :type config: dict
    """
    pool = vt_resmgr.get_pool_by_resource(resource_id)
    pool.update_resource(resource_id, config)
